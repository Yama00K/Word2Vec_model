import pickle as pkl
import numpy as np
import torch
from tqdm import tqdm
import os

def main():
    # Select mode
    print("Select mode")
    print("1: Comparison of one word vectors generated by the two models")
    print("2: Comparison of two word vectors generated by the same model")
    while True:
        user_input = input("Enter 1 or 2:")
        match user_input:
            case '1':
                print("Comparison of one word vectors generated by the two models")
                compare_two_models()
                break
            case '2':
                print("Comparison of two word vectors generated by the same model")
                compare_same_model()
                break
            case _:
                print("Invalid input. Please enter 1 or 2.")
                continue

def compare_two_models():
    # Load pickle file
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    vecs1_path = '' # vector path of O'REILLY model
    vecs2_path = '' # vector path of PyTorch model
    epoch = 10
    vecs1 = []
    vecs2 = []
    for i in tqdm(range(epoch),desc='Loading word vectors'):
        with open(os.path.join(vecs1_path, f'cbow_params_{i}.pkl'), 'rb') as f:
            data = pkl.load(f)
        vecs1.append(torch.tensor(data['word_vecs']).float().to(device))
        with open(os.path.join(vecs2_path, str(i), f'wordvecs_{i}.pkl'), 'rb') as f:
            data = pkl.load(f)
        vecs2.append(torch.tensor(data['wordvecs']).float().to(device))

    del vecs2[0]
    # Calculate mean and variance
    print("Calculating mean and variance.")
    vecs1_mean, vecs1_var = mean_vector(vecs1)
    vecs2_mean, vecs2_var = mean_vector(vecs2)

    # Print the results
    while True:
        input_word = input("Enter the word to compare:")
        if input_word not in data['word_to_id']:
            print("Invalid word. Please enter again.")
            continue
        word_id = data['word_to_id'][input_word]
        print(f"O'REILLY model [{input_word}] word vector:\n{vecs1_mean[word_id]}")
        print(f"O'REILLY model [{input_word}] word vector variance:\n{vecs1_var[word_id]}")
        print(f"PyTorch model [{input_word}] word vector:\n{vecs2_mean[word_id]}")
        print(f"PyTorch model [{input_word}] word vector variance:\n{vecs2_var[word_id]}")
        print(f"Cosine similarity of [{input_word}] word vector between two models:\n{cos_similarity(vecs1_mean[word_id], vecs2_mean[word_id])}")
        print(f"Euclidean distance of [{input_word}] word vector between two models:\n{euclidean_distance(vecs1_mean[word_id], vecs2_mean[word_id])}")
        conti = input("Do you want to continue? (y/n):")
        match conti:
            case 'y':
                print("Continuing the program.")
                continue
            case 'n':
                print("Exiting the program.")
                break
            case _:
                print("Invalid input. Exiting the program.")
                break

def compare_same_model():
    # Load pickle file
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    epoch = 10
    vecs = []
    ave = False
    while True:
        vecs_kind = input("Enter the kind of word vectors (o: O'REILLY model, p: PyTorch model):")
        match vecs_kind:
                case 'o':
                    print("Loading O'REILLY model word vectors.")
                    vecs_path = '/Volumes/share/K_YAMAZAKI/lab_mac/save_ptb/5:8/pkl' # vector path of O'REILLY model
                    for i in tqdm(range(epoch), desc='Loading word vectors'):
                        with open(os.path.join(vecs_path, f'cbow_params_{i}.pkl'), 'rb') as f:
                            data = pkl.load(f)
                        vecs.append(torch.tensor(data['word_vecs']).float().to(device))
                    break
                case 'p':
                    print("Loading PyTorch model word vectors.")
                    vecs_path = '/Volumes/share/K_YAMAZAKI/lab_win/2025-05-08_20-49-52' # vector path of PyTorch model
                    for i in tqdm(range(epoch), desc='Loading word vectors'):
                        with open(os.path.join(vecs_path, str(i), f'wordvecs_{i}.pkl'), 'rb') as f:
                            data = pkl.load(f)
                        vecs.append(torch.tensor(data['wordvecs']).float().to(device))
                    del vecs[0]
                    break
                case _:
                    print("Invalid input. Please enter again.")
                    continue

    # Calculate mean and variance
    if ave == False:
        vecs_mean = vecs[7]
    else:
        print("Calculating mean and variance.")
        vecs_mean, vecs_var = mean_vector(vecs)

    # Print the results
    while True:
        input_word1 = input("Enter the first word to compare:")
        if input_word1 not in data['word_to_id']:
            print("Invalid first word. Please enter again.")
            continue
        while True:
            input_word2 = input("Enter the sencond word to compare:")
            if input_word2 not in data['word_to_id']:
                print("Invalid second word. Please enter again.")
                continue
            break
        word_id1 = data['word_to_id'][input_word1]
        word_id2 = data['word_to_id'][input_word2]
        # print(vecs_mean[word_id1])
        # print(vecs_mean[word_id2])
        print(f"Cosine similarity of [{input_word1}] and [{input_word2}]:\n{cos_similarity(vecs_mean[word_id1], vecs_mean[word_id2])}")
        print(f"Euclidean distance of [{input_word1}] and [{input_word2}]:\n{euclidean_distance(vecs_mean[word_id1], vecs_mean[word_id2])}")
        conti = input("Do you want to continue? (y/n):")
        match conti:
            case 'y':
                print("Continuing the program.")
                continue
            case 'n':
                print("Exiting the program.")
                break
            case _:
                print("Invalid input. Exiting the program.")
                break

# Calculate mean and variance from the list of vectors
def mean_vector(vecs_list):
    stacked_vecs = torch.stack(vecs_list)
    vecs_mean = torch.mean(stacked_vecs, dim=0)
    vecs_var = torch.var(stacked_vecs, dim=0)
    return vecs_mean, vecs_var

# Calculate cosine similarity and euclidean distance
def cos_similarity(vecs1, vecs2):
    dot = torch.dot(vecs1, vecs2)
    norm1 = torch.norm(vecs1, p=2)
    norm2 = torch.norm(vecs2, p=2)
    similarity = dot / (norm1 * norm2)
    return similarity
    
# Calculate euclidean distance
def euclidean_distance(vecs1, vecs2):
    diff = vecs1 -vecs2
    distance = torch.norm(diff, p=2)
    return distance

if __name__ == "__main__":
    main()


# def cos_similarity(vecs1, vecs2):
#     dot = np.dot(vecs1, vecs2.T)
#     norm1 = np.linalg.norm(vecs1, ord=2, axis=1)
#     norm2 = np.linalg.norm(vecs2, ord=2, axis=1)
#     norm = np.outer(norm1, norm2)
#     similarity = dot / norm
#     return similarity
    
# # Calculate euclidean distance
# def euclidean_distance(vecs1, vecs2):
#     diff = vecs1[:, np.newaxis, :] - vecs2[np.newaxis, :, :]
#     distance = np.linalg.norm(diff, ord=2, axis=2)
#     return distance